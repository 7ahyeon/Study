# Docker
- **컨테이너 기반 오픈소스 가상화 플랫폼**
- 파이콘 US 2013 '리눅스 컨테이너의 미래' 솔로몬 하이크(dotCloud→Docker Inc.)
- 리눅스 상에서 컨테이너 방식으로 프로세스를 격리해서 실행하고 관리할 수 있도록 도와줌
- 계층화된 파일 시스템에 기반해 효율적으로 이미지(프로세스 실행 환경)을 구축할 수 있도록 함
- **완전히 새로운 기술이 아님! 이미 존재하는 기술을 잘 포장했음!**
- 컨테이너, 오버레이 네트워크, 유니온 파일 시스템(UFS) 등의 기술을 잘 조합하고 쉽게 만든 것
- 사용자가 원하는 기능을 간단하지만 획기적인 아이디어로 구현!

**Docker 사용**
- 이미지를 기반으로 컨테이너 실행할 수 있음
- 특정 컨테이너의 상태를 변경하여 이미지 생성 가능
- 생성된 이미지는 파일 보관 및 원격 저장소 공유 가능
- **도커만 설치되어있다면 언제 어디서든 이미지를 컨테이너로 실행 가능**

**이미지 Image**
![Docker_Image](https://github.com/7ahyeon/Study/assets/107123698/96e8969e-9dbc-40ff-9ef2-646af048bcf4)
- 컨테이너 실행에 필요한 파일과 설정값 등(모든 정보)을 포함하고 있는 것
- 상태값을 가지지 않고 변하지 않음(Immutable) 
- 같은 이미지에서 여러 개의 컨테이너 생성 가능 
- 컨테이너의 상태가 변하거나 삭제되어도 변하지 않고 남아있음

- **더이상 의존성 파일을 컴파일하거나 다른 것들을 설치할 필요 없음**
- 새로운 서버 추가시 미리 생성해둔 이미지 다운 후 컨테이너 생성
- 한 서버에 여러 개의 컨테이너 실행 가능/수천 대의 서버도 문제 없음

- Docker hub에 등록하거나 Docker Registry 저장소를 직접 만들어 관리할 수 있음
- 누구나 쉽게 이미지를 만들고 배포 가능

**레이어 저장 방식 : 유니온 파일 시스템(UFS)**
- Docker Image : 수백 메가MB의 용량 : 처음 이미지 다운(부담X) → 기존 이미지에 파일 하나 추가(수백메가 다시 다운) : 비효율
- 이미지는 여러개의 읽기 전용Read Only 레이어로 구성되고 파일이 추가되거나 수정되면 새로운 레이어 생성
- ex: ubuntu 이미지 : A+B+C 레이어 구성
- nginx 이미지(ubuntu 이미지 베이스) : A+B+C+nginx 레이어 구성
- webapp 이미지(nginx 이미지 베이스) : A+B+C+nginx+source 레이어 구성
- webapp 소스 수정! A+B+C+nginx 레이어 제외 새로운 source(ver2) 레이어만 다운 받으면 됨! (효율적인 이미지 관리 가능!)

**UFS의 Copy on Write(COW) 전략**
- 하위 레이어(base layer) 위에 새로운 layer가 쌓일 경우, 하위 layer는 READ ONLY 상태가 됨
- 상위 layer에서 하위 layer를 복사하여 사용(CoW)하기 때문에, 상위 layer는 하위 layer에 아무런 영향을 주지 않음
- 이미지 레이어를 그대로 사용하면서 컨테이너가 실행중에 생성하는 파일이나 변경된 내용은 읽기/쓰기 레이어에 저장됨
- 여러 개의 컨테이너를 생성해도 최소한의 용량만 사용
- 가상화 특성 : 이미지 용량이 크고 여러 대의 서버에 배포하는걸 감안한 설계!

**기존 이미지**
- ubuntu 이미지 : ubuntu를 실행하기 위한 모든 파일 포함
- MySQL이미지 : debian을 기반으로 MySQL을 실행하는데 필요한 파일과 실행 명령어, 포트 정보 등 포함
- Gitlab 이미지 : centos를 기반으로 ruby, go, database, redis, gitlab source, nginx등 포함

**컨테이너 Container**
- 격리된 공간에서 프로세스가 동작하는 기술(가상화)
- 호스트 운영 체제에서 애플리케이션을 실행하기 위해 격리된 경량 사일로
- 이미지를 실행한 상태 : 추가되거나 변하는 값 = 컨테이너에 저장함

**기존 가상화**
- OS 가상화, CPU 가상화(HVM) 이용(KVM), 반가상화(Xen) 
- → 클라우드 서비스 (OpenStack, AWS, Rackspace) 가상 컴퓨팅 기술의 기반 → 성능 문제

**리눅스 컨테이너 Linux Container**
- 프로세스 격리 (가볍고 빠르게 동작)
- CPU, 메모리 : 프로세스가 필요한 만큼만 추가 사용 → 성능 손실 ↓
- 새로운 컨테이너를 만드는데 걸리는 시간 : 1-2초(가상머신보다 빠름)

**기존 컨테이너(프로세스 격리)**
- Linux : cgroups(control groups), LCX(Linux Container / namespace 이용)
- FreeBSD : Jail
- Solaris : Solaris Zones
- Google : lmctfy (Let Me Contain That For You / 오픈 소스 컨테이너 기술)

**Docker**
- LXC 기반 → 자체적인 libcontainer(0.9ver) 기술 사용 → runC기술에 합쳐짐

**Docker와 VM(가상머신) 차이**

|기능|Docker|VM|
|:---:|:---:|:---:|
|구현 방식|하드웨어를 에뮬레이션하지 않고 독립된 환경에서 실행된 것처럼 보이는 특별한 제약이 가해진 프로세스 실행(컨테이너가 OS위에서 실행되는 다른 프로세스들과 정확히 같은 **계층**에서 실행)|OS나 하이퍼바이저 위에서 하드웨어를 소프트웨어로 **에뮬레이션**하고 그 위에 OS를 실행하고 그 위에 프로세스 실행|
|아키텍쳐|**호스트 운영 체제 위의 커널** 위에 빌드, 사용자 모드에서 실행되는 앱과 간단한 운영체제 API 및 서비스만 포함|자체 커널을 포함한 완전한 운영 체제 실행|
