# Docker
- **컨테이너 기반 오픈소스 가상화 플랫폼**
- 파이콘 US 2013 '리눅스 컨테이너의 미래' 솔로몬 하이크(dotCloud→Docker Inc.)
- 리눅스 상에서 컨테이너 방식으로 프로세스를 격리해서 실행하고 관리할 수 있도록 도와줌
- 계층화된 파일 시스템에 기반해 효율적으로 이미지(프로세스 실행 환경)을 구축할 수 있도록 함
- **완전히 새로운 기술이 아님! 이미 존재하는 기술을 잘 포장했음!**
- 컨테이너, 오버레이 네트워크, 유니온 파일 시스템(UFS) 등의 기술을 잘 조합하고 쉽게 만든 것
- 사용자가 원하는 기능을 간단하지만 획기적인 아이디어로 구현!
</br>
**Docker 사용**
- 이미지를 기반으로 컨테이너 실행할 수 있음
- 특정 컨테이너의 상태를 변경하여 이미지 생성 가능
- 생성된 이미지는 파일 보관 및 원격 저장소 공유 가능
- **도커만 설치되어있다면 언제 어디서든 이미지를 컨테이너로 실행 가능**



**이미지 Image**
![Docker_Image](https://github.com/7ahyeon/Study/assets/107123698/96e8969e-9dbc-40ff-9ef2-646af048bcf4)
- 컨테이너 실행에 필요한 파일과 설정값 등(모든 정보)을 포함하고 있는 것
- 상태값을 가지지 않고 변하지 않음(Immutable) 
- 같은 이미지에서 여러 개의 컨테이너 생성 가능 
- 컨테이너의 상태가 변하거나 삭제되어도 변하지 않고 남아있음



- **더이상 의존성 파일을 컴파일하거나 다른 것들을 설치할 필요 없음**
- 새로운 서버 추가시 미리 생성해둔 이미지 다운 후 컨테이너 생성
- 한 서버에 여러 개의 컨테이너 실행 가능/수천 대의 서버도 문제 없음



- Docker hub에 등록하거나 Docker Registry 저장소를 직접 만들어 관리할 수 있음
- 누구나 쉽게 이미지를 만들고 배포 가능



**레이어 저장 방식 : 유니온 파일 시스템(UFS)**
- Docker Image : 수백 메가MB의 용량 : 처음 이미지 다운(부담X) → 기존 이미지에 파일 하나 추가(수백메가 다시 다운) : 비효율
- 이미지는 여러개의 읽기 전용Read Only 레이어로 구성되고 파일이 추가되거나 수정되면 새로운 레이어 생성
- ex: ubuntu 이미지 : A+B+C 레이어 구성
- nginx 이미지(ubuntu 이미지 베이스) : A+B+C+nginx 레이어 구성
- webapp 이미지(nginx 이미지 베이스) : A+B+C+nginx+source 레이어 구성
- webapp 소스 수정! A+B+C+nginx 레이어 제외 새로운 source(ver2) 레이어만 다운 받으면 됨! (효율적인 이미지 관리 가능!)



**UFS의 Copy on Write(COW) 전략**
- 하위 레이어(base layer) 위에 새로운 layer가 쌓일 경우, 하위 layer는 READ ONLY 상태가 됨
- 상위 layer에서 하위 layer를 복사하여 사용(CoW)하기 때문에, 상위 layer는 하위 layer에 아무런 영향을 주지 않음
- 이미지 레이어를 그대로 사용하면서 컨테이너가 실행중에 생성하는 파일이나 변경된 내용은 읽기/쓰기 레이어에 저장됨
- 여러 개의 컨테이너를 생성해도 최소한의 용량만 사용
- 가상화 특성 : 이미지 용량이 크고 여러 대의 서버에 배포하는걸 감안한 설계!



**기존 이미지**
- ubuntu 이미지 : ubuntu를 실행하기 위한 모든 파일 포함
- MySQL이미지 : debian을 기반으로 MySQL을 실행하는데 필요한 파일과 실행 명령어, 포트 정보 등 포함
- Gitlab 이미지 : centos를 기반으로 ruby, go, database, redis, gitlab source, nginx등 포함



**컨테이너 Container**
- 격리된 공간에서 프로세스가 동작하는 기술(가상화)
- 호스트 운영 체제에서 애플리케이션을 실행하기 위해 격리된 경량 사일로
- 이미지를 실행한 상태 : 추가되거나 변하는 값 = 컨테이너에 저장함



**기존 가상화**
- OS 가상화, CPU 가상화(HVM) 이용(KVM), 반가상화(Xen) 
- → 클라우드 서비스 (OpenStack, AWS, Rackspace) 가상 컴퓨팅 기술의 기반 → 성능 문제



**리눅스 컨테이너 Linux Container**
- 프로세스 격리 (가볍고 빠르게 동작)
- CPU, 메모리 : 프로세스가 필요한 만큼만 추가 사용 → 성능 손실 ↓
- 새로운 컨테이너를 만드는데 걸리는 시간 : 1-2초(가상머신보다 빠름)



**기존 컨테이너(프로세스 격리)**
- Linux : cgroups(control groups), LCX(Linux Container / namespace 이용)
- FreeBSD : Jail
- Solaris : Solaris Zones
- Google : lmctfy (Let Me Contain That For You / 오픈 소스 컨테이너 기술)



**Docker**
- LXC 기반 → 자체적인 libcontainer(0.9ver) 기술 사용 → runC기술에 합쳐짐



**Docker와 VM(가상머신) 차이**

|기능|Docker|VM|
|:---:|:---:|:---:|
|구현 방식|하드웨어를 에뮬레이션하지 않고 독립된 환경에서 실행된 것처럼 보이는 특별한 제약이 가해진 프로세스 실행(컨테이너가 OS위에서 실행되는 다른 프로세스들과 정확히 같은 **계층**에서 실행)|OS나 하이퍼바이저 위에서 하드웨어를 소프트웨어로 **에뮬레이션**하고 그 위에 OS를 실행하고 그 위에 프로세스 실행|
|아키텍쳐|**호스트 운영 체제 위의** 위에 빌드/운영체제 프로세스로 실행(사용자 모드에서 실행되는 앱과 간단한 운영체제 API 및 서비스만 포함)|**자체 커널**을 포함한 완전한 운영 체제 실행|
|시스템 리소스|시스템 리소스 사용 절약|많은 시스템 리소스(CPU, 메모리 및 스토리지) 필요|
|격리|호스트 운영 체제와 VM으로부터 일부 격리(강력한 보안 경계X)|호스트 운영 체제와 VM으로부터 완전 격리(강력한 보안 경계)|
|운영체제 업데이트/업그레이드|컨테이너 내 운영체제(최신 버전의 기본 이미지를 가리키도록 빌드파일(Dockerfile) 편집/새로운 기본 이미지를 사용하여 컨테이너 이미지 다시 빌드/컨테이너 레지스트리에 이미지 푸시/배포 방법에 따라 재배포 실시|각 VM에 운영체제 업데이트 다운(업그레이드가 필요하거나 새 VM생성 필요함/시간 오래 걸림)|
|영구 스토리지|"-v" 또는 "--volume" 옵션 추가 후 컨테이너 실행(docker-v <host system directory>:<container directory>[IMAGE NAME]|단일 VM의 경우 로컬 스토리지(VHD(가상 하드 디스크))/여러 서버에서 공유하는 스토리지(파일 공유) 사용|
|부하 분산|컨테이너 자체 이동X/오케스트레이터: 클러스터 노드의 컨테이너 자동 시작/중지(부하 및 가용성의 변화 관리)|가상 머신 부하 분산 : 실행 중인 VM을 장애조치(failover) 후 클러스터의 다른 서버로 이동|
|내결함성|오케스트레이터 : 오류 발생시 해당 클러스터 노드(서버)에서 실행되는 모든 컨테이너를 신속하게 다른 클러스터 노드(서버)에 재생성|클러스터의 다른 노드(서버)로 장애 조치/새 노드(서버)에서 VM 운영체제 재시작|
|네트워킹|가상 네트워크 어댑터의 격리된 보기를 사용(적은 가상화 제공)/호스트의 방화벽을 컨테이너와 공유(적은 리소스 사용)|가상 네트워크 어댑터 사용|
|오버헤드|물리머신과 비교해도 성능저하 거의 없음|CPU는 약 5배/메모리, 파일IO은 약 2배의 시간이 걸림(성능 저하)|

  
  
  **결론**
  - 물리적 하드웨어를 논리적 분할하기 위해서 VM을 이용하는건 이전 방식
  - AWS, Nutanix 등과 같이 기반 OS를 제공하는 방식으로 컨테이너는 그 위의 서비스를 격리시켜 장애에 대비할 수 있도록 하고 개발 편리를 제공하는 방식으로 변함!
  
  
